<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="MongoDB OHLC Load Test Plan">
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments">
          <elementProp name="MONGO_URI" elementType="Argument">
            <stringProp name="Argument.name">MONGO_URI</stringProp>
            <stringProp name="Argument.value">YOUR MONGO_URI</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Your MongoDB Atlas Connection String</stringProp>
          </elementProp>
          <elementProp name="MONGO_DB_NAME" elementType="Argument">
            <stringProp name="Argument.name">MONGO_DB_NAME</stringProp>
            <stringProp name="Argument.value">YOUR DB NAME</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">The name of the database</stringProp>
          </elementProp>
          <elementProp name="MONGO_COLLECTION_NAME" elementType="Argument">
            <stringProp name="Argument.name">MONGO_COLLECTION_NAME</stringProp>
            <stringProp name="Argument.value">YOUR COLLECTION NAME</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">The name of the time-series collection</stringProp>
          </elementProp>
          <elementProp name="TOTAL_TICKERS" elementType="Argument">
            <stringProp name="Argument.name">TOTAL_TICKERS</stringProp>
            <stringProp name="Argument.value">40000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Total number of unique tickers to simulate</stringProp>
          </elementProp>
          <elementProp name="SIMULATION_MINUTES" elementType="Argument">
            <stringProp name="Argument.name">SIMULATION_MINUTES</stringProp>
            <stringProp name="Argument.value">1440</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Total minutes to generate data for (24 hours = 1440)</stringProp>
          </elementProp>
          <elementProp name="BATCH_SIZE" elementType="Argument">
            <stringProp name="Argument.name">BATCH_SIZE</stringProp>
            <stringProp name="Argument.value">1000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">How many documents to send to MongoDB in one go</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Ticker Data Generators">
        <boolProp name="ThreadGroup.delayedStart">true</boolProp>
        <intProp name="ThreadGroup.num_threads">300</intProp>
        <intProp name="ThreadGroup.ramp_time">10</intProp>
        <longProp name="ThreadGroup.duration">0</longProp>
        <longProp name="ThreadGroup.delay">0</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">false</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Generate and Insert OHLC Batch">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.mongodb.client.MongoClients
import com.mongodb.client.MongoClient
import com.mongodb.client.MongoCollection
import com.mongodb.client.MongoDatabase
import org.bson.Document
import java.time.Instant
import java.time.temporal.ChronoUnit

// A JMeter-safe way to manage a single MongoDB client connection per thread.
// `props` is a shared space across all threads, `vars` is per-thread.
// We create one client per thread and store it in the thread&apos;s variables.
if (vars.getObject(&quot;mongoClient&quot;) == null) {
    log.info(&quot;Thread &quot; + ctx.getThreadNum() + &quot;: Creating new MongoClient.&quot;)
    MongoClient mongoClient = MongoClients.create(vars.get(&quot;MONGO_URI&quot;))
    vars.putObject(&quot;mongoClient&quot;, mongoClient)

    // Also get the collection handle and store it.
    MongoDatabase database = mongoClient.getDatabase(vars.get(&quot;MONGO_DB_NAME&quot;))
    MongoCollection&lt;Document&gt; collection = database.getCollection(vars.get(&quot;MONGO_COLLECTION_NAME&quot;))
    vars.putObject(&quot;mongoCollection&quot;, collection)
}

// Retrieve the thread-local client and collection from JMeter variables
MongoClient mongoClient = (MongoClient) vars.getObject(&quot;mongoClient&quot;)
MongoCollection&lt;Document&gt; collection = (MongoCollection&lt;Document&gt;) vars.getObject(&quot;mongoCollection&quot;)
SampleResult.setSuccessful(true) // Assume success unless an error occurs

try {
    // --- CONFIGURATION ---
    int totalTickers = vars.get(&quot;TOTAL_TICKERS&quot;).toInteger()
    int simulationMinutes = vars.get(&quot;SIMULATION_MINUTES&quot;).toInteger()
    int batchSize = vars.get(&quot;BATCH_SIZE&quot;).toInteger()
    int threadNum = ctx.getThreadNum()
    int totalThreads = ctx.getThreadGroup().getNumberOfThreads()

    // --- LOGIC TO DIVIDE WORK ---
    // Each thread calculates which tickers it is responsible for.
    int tickersPerThread = totalTickers / totalThreads
    int startTicker = (threadNum * tickersPerThread) + 1
    int endTicker = (threadNum + 1) * tickersPerThread
    // The last thread picks up any remainders
    if (threadNum == totalThreads - 1) {
        endTicker = totalTickers
    }
    
    log.info(&quot;Thread &quot; + threadNum + &quot; is processing tickers from &quot; + startTicker + &quot; to &quot; + endTicker)

    Random rand = new Random()
    List&lt;Document&gt; documentsBatch = new ArrayList&lt;&gt;()

    // We will use a map to store the last close price for each ticker this thread manages.
    Map&lt;String, Double&gt; lastClosePrices = new HashMap&lt;&gt;()

    // --- MAIN GENERATION LOOP ---
    // Loop through each minute of the 24-hour simulation period
    for (int minute = 0; minute &lt; simulationMinutes; minute++) {
        Instant currentTimestamp = Instant.now().minus(simulationMinutes, ChronoUnit.MINUTES).plus(minute, ChronoUnit.MINUTES)

        // For each minute, loop through the tickers assigned to this thread
        for (int i = startTicker; i &lt;= endTicker; i++) {
            String tickerSymbol = &quot;TICKER_&quot; + i

            // Get the last close price, or generate a random starting price
            double lastClose = lastClosePrices.getOrDefault(tickerSymbol, 100.0 + rand.nextDouble() * 500)
            
            // --- GENERATE REALISTIC OHLC DATA ---
            double open = lastClose
            // Fluctuation is between -2% and +2% of the open price
            double fluctuation = (rand.nextDouble() * 0.04) - 0.02
            double close = open * (1 + fluctuation)
            
            // Ensure high/low are logical
            double high = Math.max(open, close) * (1 + rand.nextDouble() * 0.01) // High is slightly higher
            double low = Math.min(open, close) * (1 - rand.nextDouble() * 0.01)   // Low is slightly lower
            
            // Format to 2 decimal places
            open = Math.round(open * 100.0) / 100.0
            high = Math.round(high * 100.0) / 100.0
            low = Math.round(low * 100.0) / 100.0
            close = Math.round(close * 100.0) / 100.0

            // Update the last close price for the next iteration
            lastClosePrices.put(tickerSymbol, close)
            
            // --- CREATE THE BSON DOCUMENT ---
            Document doc = new Document()
                .append(&quot;timestamp&quot;, new Date(currentTimestamp.toEpochMilli()))
                .append(&quot;metadata&quot;, new Document(&quot;symbol&quot;, tickerSymbol))
                .append(&quot;open&quot;, open)
                .append(&quot;high&quot;, high)
                .append(&quot;low&quot;, low)
                .append(&quot;close&quot;, close)
            
            documentsBatch.add(doc)

            // --- BATCH INSERT LOGIC ---
            // When the batch is full, send it to MongoDB and clear the list.
            if (documentsBatch.size() &gt;= batchSize) {
                collection.insertMany(documentsBatch)
                documentsBatch.clear()
            }
        }
    }

    // Insert any remaining documents after the loops finish
    if (!documentsBatch.isEmpty()) {
        collection.insertMany(documentsBatch)
        documentsBatch.clear()
    }

} catch (Exception e) {
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(&quot;Error: &quot; + e.getMessage())
    log.error(&quot;Error in JSR223 Sampler: &quot;, e)
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
